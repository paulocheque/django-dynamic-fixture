Description
-----------

A full library to create dynamic model instances for testing purposes.

Installation
------------

	pip install django-dynamic-fixture

#### or

	1. Download zip file 
	2. Extract it
	3. Execute in the extracted directory: python setup.py install

#### Upgrade:

	pip install django-dynamic-fixture --upgrade --no-deps

# Motivation
  * It is a TERRIBLE practice to use STATIC data in tests. 
  * Create dynamic fixture for each model is boring and it produces a lot of replicated code.
  * It is a bad idea to use uncontrolled data in tests, like bizarre random data.

# Comparison with another fixture tools

  * We tried to use another fixture tools in a big Django project but the experience was not satisfactory. 
  * Either they are incomplete, or bugged or it produces erratic tests, because they use random and uncontrolled data.
  * Also, the syntax of others tools is too verbose, which polutes the tests.
  * Complete, lean and practice documentation.
  * It is hard to debug tests with another tools.
  * List of other tools: http://djangopackages.com/grids/g/fixtures

# Features
  * Highly customizable: you can customize fields recursively
  * Deal with unique=True
  * Deal with cyclic dependencies (including self references)
  * Deal with many to many relationship (common M2M or M2M with additional data, i.e. through='table')
  * Deal with custom fields (specially if the custom field inherit of a django field)
  * It is supported for parallel tests
  * Deal with auto calculated attributes
  * It is easy to debug errors

# Example of Usage

	from django_dynamic_fixture import N, G, F, P
	#or use old default names:
	#from django_dynamic_fixture import new, get, DynamicFixture as F, 	print_field_values

### Models:

	from django.db import models

	class ModelA(models.Model): pass

	class ModelY(models.Model):
    	other_text = models.CharField()
    	other_list = models.ManyToManyField('ModelA')

	class ModelX(models.Model):
    	some_text = models.CharField(null=True)
    	parent_left = models.ForeingKey('self')
    	y_reference = models.ForeingKey('ModelY')
    	list_a = models.ManyToManyField('ModelA')

### Summary:

 * **DynamicFixture (F):** receive arguments and create model instances.
 * **new:** it is just a wrapper: it creates a F to create a not saved model instance.
 * **get:** basically, call the new method and save the instance. You can set ManyToMany fields only after the instance is saved.

## Examples:

	instance_of_modelx = N(ModelX)
	assert instance_of_modelx.some_text != None
	assert instance_of_modelx.parent_left != None
	assert instance_of_modelx.parent_left.parent_left == None
	assert instance_of_modelx.id == None # new do not save the instance
	assert instance_of_modelx.y_reference.id != None # save dependencies by default
	assert len(instance_of_modelx.list_a.all()) == 0 # do not create 	many2many fields by default

	instance_of_modelx = N(ModelX, fill_nullable_fields=False) # default = True
	assert instance_of_modelx.some_text == None

#### You can ignore fields, but do not ignore required fields (with null=False).
	instance_of_modelx = G(ModelX, ignore_fields=['some_text'])
	assert instance_of_modelx.some_text == None

#### Very nice feature to work with trees
	instance_of_modelx = N(ModelX, number_of_laps=2) # default = 1
	assert instance_of_modelx.parent_left != None
	assert instance_of_modelx.parent_left.parent_left != None
	assert instance_of_modelx.parent_left.parent_left.parent_left == None

#### This feature is specially useful to test search methods
	instance_of_modelx = N(ModelX, some_text='some fixed data') # attribute accepts static data
	assert instance_of_modelx.some_text == 'some fixed data'

#### Use this with attention. First, check for design mistakes
	instance_of_modelx = N(ModelX, id=99999) # you can define the id too
	assert instance_of_modelx.id == 99999

#### You can create your own function to create data..
	instance_of_modelx = N(ModelX, some_text=lambda field: field.name) # attribute accepts callables
	assert instance_of_modelx.some_text == 'some_text'

#### Use this with attention, you can get an error if you try to save an 	instance with not saved dependencies
	instance_of_modelx = N(ModelX, persist_dependencies=False)
	assert instance_of_modelx.y_reference.id == None

	instance_of_modelx = G(ModelX) # get save the model instance
	assert instance_of_modelx.id != None

	instance_of_modelx = G(ModelX, list_a=2) # Many2Many can receive a number of instances to be created
	assert len(instance_of_modelx.list_a.all()) == 2

	instance_of_modelx = G(ModelX, list_a=[F(), F(), F()]) # Many2Many can receive a list of DynamicFixtures
	assert len(instance_of_modelx.list_a.all()) == 3

	a = G(ModelA)
	instance_of_modelx = G(ModelX, list_a=[F(), a, F()]) # Many2Many can receive 	a list of instances
	assert len(instance_of_modelx.list_a.all()) == 3

#### You can pass arguments to F (DynamicFixture) recursively. This works for ForeignKey and ManyToMany Fields! Easy and customizable!
	instance_of_modelx = G(ModelX, parent_left=F(other_text='wow', other_list=2))
	assert len(instance_of_modelx.y_reference.other_list.all()) == 2

#### Highly recursivable example:
	# X has a ForeignKey to A
	# A has a ForeignKey to B
	# B has a ForeignKey to C
	# this will create instances of C, B, A and X (in this order). Attribute d of C will be 'some value'
	G(X, a=F(b=F(c=F(d='some value'))))


#### For Debug:
	P(instance_of_modelx)

#### Custom FileField:
	class ModelX(models.Model):
    	my_file = models.FileField(upload_to='/')

	from tempfile import mkstemp
	pdf_a = File(open(mkstemp()[1], 'w'), name='a.pdf')
	G(ModelX, my_file=pdf_a)

#### Copier
	G(ModelX, my_field=C('my_field_y.x'))

#### Shelve/Library
	G(ModelX, my_field='x', shelve=True)
	G(ModelX, use_library=True)

#### Named Shelve
	G(ModelX, my_field='x', shelve='some name')
	G(ModelX, use_library=True, named_shelve='some name')


#### Shelving before all tests of a module:
	def setUpModule():
    	N(ModelX, my_field='x', shelve=True)
    
#### Shelving before all tests of all modules:
	Put the code in the tests.py or tests/__init__.py of specific application.
	N(ModelX, my_field='x', shelve=True)

**OR**

**Add in ddf_setup.py:**
	
	N(ModelX, my_field='x', shelve=True)

**Run with nose plugin:**
	
	python manage.py test --with-ddf-setup

 
Decorators
-------------

	from django_dynamic_fixture.decorators import skip_for_database, only_for_database, SQLITE3 

	@only_for_database(SQLITE3)
	def test_something1(self): pass

	@skip_for_database(SQLITE3)
	def test_something2(self): pass

	@only_for_database("some value used in settings.DATABASES['default']['ENGINE']")
	def test_something3(self): pass

	@skip_for_database("some value used in settings.DATABASES['default']['ENGINE']")
	def test_something4(self): pass


Queries Module
--------------

	python manage.py test --with-queries
	python manage.py count_queries_on_save


Links of Comments
-----------------

  * http://www.reddit.com/r/django/comments/fv1re/django_dynamic_fixture
  * http://djangopackages.com/grids/g/fixtures/
  * http://news.ycombinator.com/item?id=2275406
  * http://pythonsmalltalk.blogspot.com/2011/02/django-dynamic-fixture.html
  * http://pythonsmalltalk.blogspot.com/2011/03/django-dynamic-fixture-121.html
  * http://pypi.python.org/pypi/django-dynamic-fixture/
  * http://code.activestate.com/pypm/django-dynamic-fixture
  * http://groups.google.com/group/django-mptt-dev/browse_thread/thread/d9eb9e22ad4aa656
  * http://groups.google.com/group/django-users/browse_thread/thread/1346a60008c21a7b
  * http://groups.google.com/group/django-brasil/browse_thread/thread/757df09d3c3be81d
  * http://linux.softpedia.com/get/Internet/HTTP-WWW-/django-dynamic-fixture-68711.shtml


Testing
-------
	python manage.py test
	python manage.py test --with-coverage --cover-inclusive --cover-html --cover-package=django_dynamic_fixture.* --with-queries

